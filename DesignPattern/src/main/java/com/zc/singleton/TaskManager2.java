package com.zc.singleton;

/**
 * 单例模式  --饿汉式
 *
 *
 *   饿汉式单例类与懒汉式单例类比较
 *
 *   饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以 确保实例的唯一性；
 *   从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因 此要优于懒汉式单例。因此从资源利用效率角度
 *   来讲，饿汉式单例不及懒汉式单例，而且在系统 加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。
 *
 *   懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，
 *   特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现
 *   多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。
 *
 */
public class TaskManager2 {

    //将构造方法私有化
    private TaskManager2(){ }

    /**
     * 当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯 一实例将被创建。
     * 如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现 创建多个单例对象的情况，
     * 可确保单例对象的唯一性
     */

    private static TaskManager2 taskManager = new TaskManager2();

    //提供公有获取实例方法
    public static TaskManager2 getInstance(){
        return taskManager;
    }
}
